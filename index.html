<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>memori</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>✂️</text></svg>">
	<style>
		:root {
			--color-bg-body: #f5f5f0;
			--color-bg-page: #fafaf8;
			--color-grid-line: #d0d0d0;
			--color-accent: #4a90e2;
			--color-white: white;
		}

		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			background: var(--color-bg-body);
			display: flex;
			justify-content: center;
			align-items: flex-start;
			min-height: 100vh;
			padding: 20px;
		}

		.page {
			width: 8.5in;
			height: 11in;
			background: var(--color-bg-page);
			position: relative;
			box-shadow: 0 2px 10px rgba(0,0,0,0.1);
			transform-origin: top center;
		}

		.grid {
			position: absolute;
			top: calc((11in - 264mm) / 2);
			left: calc((8.5in - 200mm) / 2);
			display: grid;
			grid-template-columns: repeat(50, 4mm);
			grid-template-rows: repeat(66, 4mm);
			gap: 0;
			line-height: 0;
		}

		.grid-cell {
			width: 4mm;
			height: 4mm;
			box-sizing: border-box;
			border-right: 1px dashed var(--color-grid-line);
			border-bottom: 1px dashed var(--color-grid-line);
			margin: 0;
			padding: 0;
			display: block;
		}

		.grid-cell:nth-child(-n+50) {
			border-top: 1px dashed var(--color-grid-line);
		}

		.grid-cell:nth-child(50n+1) {
			border-left: 1px dashed var(--color-grid-line);
		}

		.image-container {
			position: absolute;
			cursor: move;
			outline: 2px solid transparent;
			outline-offset: -2px;
			transition: outline-color 0.2s;
			background: var(--color-bg-page);
		}

		.image-container:hover {
			outline-color: var(--color-accent);
		}

		.image-container.dragging {
			opacity: 0.7;
			outline-color: var(--color-accent);
		}

		.image-container.resizing {
			outline-color: var(--color-accent);
		}

		body.resizing *,
		body.dragging * {
			cursor: inherit !important;
		}

		.image-container img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			display: block;
			pointer-events: none;
		}

		.resize-handle {
			position: absolute;
			background: var(--color-accent);
			opacity: 0;
			transition: opacity 0.2s;
		}

		.image-container:hover .resize-handle {
			opacity: 0.8;
		}

		.resize-handle.corner {
			width: 10px;
			height: 10px;
			background: transparent;
		}

		.resize-handle.corner::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: var(--color-accent);
			border-radius: 50%;
		}

		.resize-handle.edge {
			background: transparent;
		}

		.resize-handle.n { top: -5px; left: 5px; right: 5px; height: 10px; cursor: n-resize; }
		.resize-handle.s { bottom: -5px; left: 5px; right: 5px; height: 10px; cursor: s-resize; }
		.resize-handle.e { right: -5px; top: 5px; bottom: 5px; width: 10px; cursor: e-resize; }
		.resize-handle.w { left: -5px; top: 5px; bottom: 5px; width: 10px; cursor: w-resize; }
		.resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
		.resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
		.resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
		.resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }

		@media print {
			* {
				-webkit-print-color-adjust: exact !important;
				print-color-adjust: exact !important;
			}

			body {
				background: var(--color-white);
				padding: 0;
				margin: 0;
				display: block;
				align-items: initial;
				justify-content: initial;
			}

			.page {
				width: 8.5in;
				height: 11in;
				box-shadow: none;
				margin: 0;
				padding: 0;
				background: var(--color-white);
				transform: none !important;
				position: relative;
			}

			.grid {
				position: absolute;
				top: calc((11in - 264mm) / 2);
				left: calc((8.5in - 200mm) / 2);
				display: grid;
				grid-template-columns: repeat(50, 4mm);
				grid-template-rows: repeat(66, 4mm);
			}

			.grid-cell {
				border-right: 1px dashed var(--color-grid-line) !important;
				border-bottom: 1px dashed var(--color-grid-line) !important;
				box-sizing: border-box !important;
				width: 4mm !important;
				height: 4mm !important;
				margin: 0 !important;
				padding: 0 !important;
			}

			.grid-cell:nth-child(-n+50) {
				border-top: 1px dashed var(--color-grid-line) !important;
			}

			.grid-cell:nth-child(50n+1) {
				border-left: 1px dashed var(--color-grid-line) !important;
			}

			.image-container {
				outline: none !important;
				position: absolute !important;
				background: var(--color-white) !important;
			}

			.image-container img {
				width: 100% !important;
				height: 100% !important;
				object-fit: cover !important;
			}

			.resize-handle {
				display: none !important;
			}
		}

		@page {
			size: 8.5in 11in;
			margin: 0;
		}
	</style>
</head>
<body>
	<div class="page">
		<div class="grid" id="grid"></div>
	</div>

	<script>
		const MM_TO_PX = 96 / 25.4;
		const CELL_SIZE_MM = 4;
		const CELL_SIZE_PX = CELL_SIZE_MM * MM_TO_PX;
		const GRID_OFFSET_IN = 0.25;
		const GRID_OFFSET_PX = GRID_OFFSET_IN * 96;
		const GRID_COLS = 50;
		const GRID_ROWS = 66;

		const grid = document.getElementById('grid');
		const page = document.querySelector('.page');

		// Create grid cells
		for (let i = 0; i < GRID_COLS * GRID_ROWS; i++) {
			const cell = document.createElement('div');
			cell.className = 'grid-cell';
			grid.appendChild(cell);
		}

		let images = [];
		let dragState = null;
		let resizeState = null;

		// Prevent default drag behavior on entire document
		document.addEventListener('dragover', (e) => {
			e.preventDefault();
			e.stopPropagation();
		});

		document.addEventListener('drop', async (e) => {
			e.preventDefault();
			e.stopPropagation();

			const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
			if (files.length === 0) return;

			// Get drop position relative to the grid
			const gridRect = grid.getBoundingClientRect();
			const gridWidth = GRID_COLS * CELL_SIZE_PX;
			const gridHeight = GRID_ROWS * CELL_SIZE_PX;

			// Clamp drop position to grid boundaries
			let dropX = e.clientX - gridRect.left;
			let dropY = e.clientY - gridRect.top;
			dropX = Math.max(0, Math.min(gridWidth, dropX));
			dropY = Math.max(0, Math.min(gridHeight, dropY));

			// Load first image to get base dimensions
			let firstImageDimensions = null;
			if (files.length > 0) {
				const firstFile = files[0];
				const reader = new FileReader();
				const dataUrl = await new Promise(resolve => {
					reader.onload = (e) => resolve(e.target.result);
					reader.readAsDataURL(firstFile);
				});

				const img = new Image();
				await new Promise(resolve => {
					img.onload = () => {
						const aspectRatio = img.width / img.height;
						let widthCells, heightCells;
						if (aspectRatio >= 1) {
							heightCells = 5;
							widthCells = Math.round(heightCells * aspectRatio);
						} else {
							widthCells = 5;
							heightCells = Math.round(widthCells / aspectRatio);
						}
						widthCells = Math.min(widthCells, GRID_COLS);
						heightCells = Math.min(heightCells, GRID_ROWS);
						firstImageDimensions = { widthCells, heightCells };
						resolve();
					};
					img.src = dataUrl;
				});
			}

			// Now process all files
			files.forEach((file, idx) => {
				const reader = new FileReader();
				reader.onload = (event) => {
					const img = new Image();
					img.onload = () => {
						const aspectRatio = img.width / img.height;

						// Set smaller dimension to 5 cells, calculate larger dimension
						let widthCells, heightCells;
						if (aspectRatio >= 1) {
							// Width is larger or equal
							heightCells = 5;
							widthCells = Math.round(heightCells * aspectRatio);
						} else {
							// Height is larger
							widthCells = 5;
							heightCells = Math.round(widthCells / aspectRatio);
						}

						// Clamp to grid boundaries
						widthCells = Math.min(widthCells, GRID_COLS);
						heightCells = Math.min(heightCells, GRID_ROWS);

						// Calculate position with first image's center under drop point
						let xCell = Math.round(dropX / CELL_SIZE_PX - firstImageDimensions.widthCells / 2) + (idx * 2);
						let yCell = Math.round(dropY / CELL_SIZE_PX - firstImageDimensions.heightCells / 2);

						// Ensure image stays within grid bounds
						xCell = Math.max(0, Math.min(GRID_COLS - widthCells, xCell));
						yCell = Math.max(0, Math.min(GRID_ROWS - heightCells, yCell));

						addImage(event.target.result, xCell, yCell, widthCells, heightCells, idx + 1);
					};
					img.src = event.target.result;
				};
				reader.readAsDataURL(file);
			});
		});

		function addImage(src, xCell, yCell, widthCells, heightCells, zIndex = 0) {
			const container = document.createElement('div');
			container.className = 'image-container';
			if (zIndex > 0) {
				container.style.zIndex = zIndex;
			}

			const img = document.createElement('img');
			img.src = src;
			container.appendChild(img);

			// Add resize handles
			const handles = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
			handles.forEach(dir => {
				const handle = document.createElement('div');
				handle.className = `resize-handle ${dir.length === 1 ? 'edge' : 'corner'} ${dir}`;
				handle.dataset.direction = dir;
				container.appendChild(handle);
			});

			const imageData = { container, xCell, yCell, widthCells, heightCells };
			images.push(imageData);

			updateImagePosition(imageData);
			grid.appendChild(container);

			setupImageHandlers(imageData);
		}

		function updateImagePosition(img) {
			img.container.style.left = img.xCell * CELL_SIZE_PX + 'px';
			img.container.style.top = img.yCell * CELL_SIZE_PX + 'px';
			img.container.style.width = img.widthCells * CELL_SIZE_PX + 'px';
			img.container.style.height = img.heightCells * CELL_SIZE_PX + 'px';
		}

		function setupImageHandlers(imageData) {
			const container = imageData.container;

			// Moving / Deleting
			container.addEventListener('mousedown', (e) => {
				if (e.target.classList.contains('resize-handle')) return;

				e.preventDefault();

				// Shift-click to delete
				if (e.shiftKey) {
					const index = images.indexOf(imageData);
					if (index > -1) {
						images.splice(index, 1);
					}
					container.remove();
					return;
				}

				// Lock cursor to move during drag operation
				document.body.style.cursor = 'move';
				document.body.classList.add('dragging');

				dragState = {
					image: imageData,
					startX: e.clientX,
					startY: e.clientY,
					startXCell: imageData.xCell,
					startYCell: imageData.yCell
				};
				container.classList.add('dragging');
			});

			// Resizing
			container.querySelectorAll('.resize-handle').forEach(handle => {
				handle.addEventListener('mousedown', (e) => {
					e.preventDefault();
					e.stopPropagation();

					// Get the cursor style from the handle and apply it to the body
					const cursorStyle = window.getComputedStyle(handle).cursor;
					document.body.style.cursor = cursorStyle;
					document.body.classList.add('resizing');

					resizeState = {
						image: imageData,
						direction: handle.dataset.direction,
						startX: e.clientX,
						startY: e.clientY,
						startXCell: imageData.xCell,
						startYCell: imageData.yCell,
						startWidthCells: imageData.widthCells,
						startHeightCells: imageData.heightCells
					};
					container.classList.add('resizing');
				});
			});
		}

		document.addEventListener('mousemove', (e) => {
			if (dragState) {
				const dx = e.clientX - dragState.startX;
				const dy = e.clientY - dragState.startY;

				const dxCells = Math.round(dx / CELL_SIZE_PX);
				const dyCells = Math.round(dy / CELL_SIZE_PX);

				const newXCell = Math.max(0, Math.min(GRID_COLS - dragState.image.widthCells, dragState.startXCell + dxCells));
				const newYCell = Math.max(0, Math.min(GRID_ROWS - dragState.image.heightCells, dragState.startYCell + dyCells));

				dragState.image.xCell = newXCell;
				dragState.image.yCell = newYCell;
				updateImagePosition(dragState.image);
			}

			if (resizeState) {
				const dx = e.clientX - resizeState.startX;
				const dy = e.clientY - resizeState.startY;

				const dxCells = Math.round(dx / CELL_SIZE_PX);
				const dyCells = Math.round(dy / CELL_SIZE_PX);

				const dir = resizeState.direction;
				const img = resizeState.image;

				let newX = img.xCell;
				let newY = img.yCell;
				let newW = img.widthCells;
				let newH = img.heightCells;

				if (dir.includes('e')) {
					const proposedW = Math.max(1, resizeState.startWidthCells + dxCells);
					// Clamp to grid boundary
					newW = Math.min(proposedW, GRID_COLS - resizeState.startXCell);
				}
				if (dir.includes('w')) {
					const delta = Math.min(dxCells, resizeState.startWidthCells - 1);
					const proposedX = resizeState.startXCell + delta;
					// Clamp to grid boundary
					const clampedX = Math.max(0, proposedX);
					newX = clampedX;
					newW = resizeState.startWidthCells - (clampedX - resizeState.startXCell);
				}
				if (dir.includes('s')) {
					const proposedH = Math.max(1, resizeState.startHeightCells + dyCells);
					// Clamp to grid boundary
					newH = Math.min(proposedH, GRID_ROWS - resizeState.startYCell);
				}
				if (dir.includes('n')) {
					const delta = Math.min(dyCells, resizeState.startHeightCells - 1);
					const proposedY = resizeState.startYCell + delta;
					// Clamp to grid boundary
					const clampedY = Math.max(0, proposedY);
					newY = clampedY;
					newH = resizeState.startHeightCells - (clampedY - resizeState.startYCell);
				}

				img.xCell = newX;
				img.yCell = newY;
				img.widthCells = newW;
				img.heightCells = newH;
				updateImagePosition(img);
			}
		});

		document.addEventListener('mouseup', () => {
			if (dragState) {
				dragState.image.container.classList.remove('dragging');
				dragState = null;
				// Restore the default cursor
				document.body.style.cursor = '';
				document.body.classList.remove('dragging');
			}
			if (resizeState) {
				resizeState.image.container.classList.remove('resizing');
				resizeState = null;
				// Restore the default cursor
				document.body.style.cursor = '';
				document.body.classList.remove('resizing');
			}
		});
	</script>
</body>
</html>
